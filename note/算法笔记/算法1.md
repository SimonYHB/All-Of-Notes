- 01.复杂度





- 线性表 （数组、列表、栈、队列、哈希表）10-接口测试
  - 02 数组

    - 动态数组----------

  - 03 链表

    - 单向链表
    - 双向链表
    - 单向循环链表
    - 双向循环链表
    - 静态链表（数组）

  - 04 栈 （动态数组）

  - 05 队列 （双向链表或动态数组）

    - 双端链表实现
      - 队列
      - 双端队列
    - 动态数组实现
      - 循环队列
      - 循环双端队列

  - 06 二叉树 

    - 性质

      - 非空二叉树的第 i 层，最多有 2^(i-1) 个节点 
      - 在高度为 h 的二叉树上最多有 2^h-1个节点
      - 对于任何一棵非空二叉树，如果叶子节点个数为 n0，度为 2 的节点个数为 n2，则有: n0 = n2 + 1
        - 假设度为 1 的节点个数为 n1，那么二叉树的节点总数 n = n0 + n1 + n2
        - 二叉树的边数 T = n1 + 2 * n2 = n - 1 = n0 + n1 + n2 - 1
        - 因此 n0 = n2 + 1

    - 遍历

      - 前序遍历

        - **根节点**、前序遍历左子树、前序遍历右子树

      - 中序遍历

        - 中序遍历右子树、**根节点**、中序遍历左子树
        - 中序遍历左子树、**根节点**、中序遍历右子树
        - 前驱节点：中序遍历的前一个节点
          - 左子树不为空时为左子树的最右节点 node.left.right == null ? -> right.right
          - 左子树为空时，在父节点的右子树中 node == node.parent.right ? -> parent.parent
          - 左子树为空且没有父节点，则没有前驱节点
        - 后续节点：中序遍历的后一个节点
          - 右子树的最左节点

      - 后序遍历

        - 后序遍历左子树、后续遍历右子树、**根节点**

      - 层序遍历

        - 从上到下、从左到右依次访问每一个节点 

          ```java
          public void levelOrderTransversal() {
            if (root == null) return;
            Queue<Node<E>> queue = New LinkedList<>();
            queue.offer(root);
            while (!queue.isEmpty()) {
              Node<E> node = queue.poll();
              System.out.print(node.element);
              if (node.left != null) {
                queue.offer(node.list);
              }
              if (node.right != null) {
                queue.offer(node.right)
              }
            }
          }
          ```

        - 二叉树高度
        - 判断是否是完全二叉树

      - 根据遍历结果重构二叉树

        - 前序遍历 + 中序遍历 = 唯一的一棵二叉树
        - 后续遍历 + 中序遍历 = 唯一的一棵二叉树
        - 前序遍历 + 后续遍历 = 若是真二叉树（度为2或度为0）则是唯一的，否则不唯一（无法区分左右子树有一边是空的场景）

  - 07 二叉搜索树（BST）

    - 是什么
      - 任意一个节点的指都大于其左子树所有节点的值
      - 任意一个节点的指都小于其右子树所有节点的值
      - 它的左右子树也是一棵BST
    - 删除节点
      - 叶子节点
        - 直接删除
      - 度为1的节点
        - 用子节点替代原节点
      - 度为2的节点
        - 先用前驱或者后继节点的值覆盖原节点值
        - 然后删除响应的前驱或者后续节点
        - 如果一个节点的度为2，那么它的前驱、后续节点的度只可能是1和0

  - AVL
    - 平衡二叉搜索树的一种
    - 平衡因子：某节点左右子树的高度差
    - AVL特点：每个节点的平衡因子只可能是1、0、-1
    - 添加节点位置 - 平衡调整方式
      - 可能会导致所有祖先节点都失衡
      - 只要让高度最低的失衡节点恢复平衡，整棵树就会恢复平衡，只需要调整O(1)
      - LL - 右旋转
      - RR - 左旋转
      - LR - 左旋转+右旋转
      - RL - 右旋转+左旋转
    - 删除节点
      - 可能会导致父节点或祖先节点其中一个失衡
      - 恢复平衡后，可能会导致更高的祖先节点失衡，最多需要调整O(logn)
    - 平均时间复杂度
      - 搜索：O(logn)
      - 添加：O(logn)+O(1)
      - 删除：O(logn)+Olog(n)
    
  - 08 B树

    - 平衡的多路搜索树，n阶表示最多的子节点数
    - 特点
      - 一个节点可以存储多个元素，有多个子节点
      - 拥有二叉搜索路的一些性质
      - 平衡，每个节点的所有子树高度一致
      - 比较矮
    - m阶B树性质 (假设一个节点存储的元素个数为x)
      - 根节点元素： 1 <= x <= m-1
      - 非根节点元素：「m/2 -1 <= x <= m-1
      - 根节点的子节点的个数y： 2 <= y <= m
      - 非根节点的子节点个数y： 「m/2 -2 <= y <= m
      - 非子节点中，如果有 x 个元素，则有x+1个子节点
    - 添加 - 上溢
      - 添加后非根节点的元素个数大于 m-1 (m指m阶B树)
      - 解决：分离
      - 根节点上溢会使高度+1
    - 删除 - 下溢
      - 删除后非根节点的元素个数小与 「m/2 -1 
      - 解决：旋转和合并
      - 根节点下溢出会使高度-1
    - B树可以通过二叉搜索树多代节点合并转换
      - 2代合并的超级节点，嘴都要拥有4个子节点
      - m代合并的超级节点，最又拥有2^m个子节点

  - 09 红黑树

    - 平衡的二叉B树

    - 什么是红黑树（性质）

      1. 节点是 RED 或者 BLACK
      2. 根节点是BLACK
      3. 叶子节点都是BLACK
      4. RED节点的子节点都是BLACK
         - RED节点的parent都是BLACK
         - 从根节点到叶子节点的所有路径上不能有2个连续的RED节点
      5. 从任一节点到叶子节点的所有路径都包含相同数目的BLACK节点

    - 红黑树的平衡

      - 性质保证了红黑树等价于4阶B树
      - 平衡标准：没有一条路径会大于其他路径的2倍（黑高度平衡）
      - 最大高度： 2*log2(N+1)

    - 红黑树和4阶B树具有等价性，Black节点个数与4阶B树节点个数相等

    - 添加

      - 添加的节点默认为RED
      - 场景
        - 黑加红 4种
        - 红加红 8种

    - 删除

      - 删实际删除的都是四阶B树的叶子节点
      - 场景
        - 删红
        - 删黑

    - 平均时间复杂度

      - 搜索/添加/删除： O(logn)，O(1)次的旋转操作

    - AVLT vs RBT

      - AVL

        - 平衡标准比较严格：每个左右子树的高度差不超过1 
        - 最大高度是 1.44 ∗ log2 n + 2 − 1.328（100W个节点，AVL树最大树高28） 
        - 搜索、添加、删除都是 O(logn) 复杂度，其中添加仅需 O(1) 次旋转调整、删除最多需要 O(logn) 次旋转调整

      - 红黑树

        - 平衡标准比较宽松：没有一条路径会大于其他路径的2倍 

        - 最大高度是 2 ∗ log2(n + 1)（ 100W个节点，红黑树最大树高40） 

        - 搜索、添加、删除都是 O(logn) 复杂度，其中添加、删除都仅需 O(1) 次旋转调整

      - 搜索的次数远远大于插入和删除，选择AVL树；搜索、插入、删除次数几乎差不多，选择红黑树

      - 相对于AVL树来说，红黑树牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树 

      - 红黑树的平均统计性能优于AVL树，实际应用中更多选择使用红黑树

  - 复习

    - AVL
      - 平衡因子
        - 每个节点的平衡因子只会是1或0 超过1则失衡
      - 添加节点
        - 通过二叉搜索的方式找到添加位置
        - 添加后更新节点平衡因子，找到第一个不平衡的节点
        - 判断节点的子高节点和孙子高节点的位置，并进行相应旋转
          - left-left -> 节点右旋转
          - left-right -> 子高节点左旋转 + 节点右旋转
          - right-right -> 节点左旋转
          - right-left -> 子高节点右旋转 + 节点左旋转
        - 第一个不平衡的节点通过旋转平衡后，整棵树就恢复平衡
      - 删除节点
        - 实际移除的都是叶子节点
          - 找到要删除的节点后，如果是度为2的非叶子节点，则将其前驱或后继节点覆盖要删除的节点，然后删除该前驱或后继节点
          - 如果是度为1则让父节点指向自己的子节点
          - 叶子节点则直接删除
        - 删除后恢复平衡操作与添加相同
        - 第一个不平衡的节点通过旋转平衡后，可能会导致更高祖先节点失衡(当前子树高度-1)，最多需要 O(logn)次调整
      
    - B树

      - m阶B树性质
        - 假设一个节点存储的元素个数为x
        - 根节点： 1 ≤ x ≤ m − 1
        - 非根节点：┌ m/2 ┐ − 1 ≤ x ≤ m − 1
        - 子节点：y = x + 1
          - 根节点：2 ≤ y ≤ m
          - 非根节点：┌ m/2 ┐  ≤ y ≤ m 
      - 添加
        - 插入的元素必定是叶子节点
        - 可能出现上溢，即所在节点元素个数过多
        - 上溢时将该位置的元素向上与父节点合并，并将其左右的元素分裂成2个子节点
        - 一次分裂合并后可能导致父节点上溢，直到根节点（高度+1）
      - 删除
        - 叶子节点的元素可直接删除
        - 非叶子节点
          - 找到该节点的前驱或后继元素，覆盖删除节点值，再讲前驱或后续元素删除
          - 最后实际删除的元素是在叶子节点
        - 可能出现下溢，即所在节点元素过少
        - 如果下溢节点临近的兄弟节点有至少 ┌ m/2 ┐ 个元素，可向其借元素
          - 将父节点的临近元素a插入到下溢节点的首位
          - 将兄弟节点的最大元素替代临近元素a
        - 如果兄弟节点元素不够，即只有 ┌ m/2 ┐ - 1 个元素，则将父节点和其左右节点进行合并
          - 合并后的元素个数为 ┌ m/2 ┐ + ┌ m/2 ┐ − 2，不超过 m − 1
          - 该方式可能导致父节点下溢出，直至根节点（高度-1）

    - 红黑树

      - 性质

        1. 节点是 RED 或者 BLACK
        2. 根节点是BLACK
        3. 叶子节点都是BLACK
        4. RED节点的子节点都是BLACK
           - RED节点的parent都是BLACK
           - 从根节点到叶子节点的所有路径上不能有2个连续的RED节点
        5. 从任一节点到叶子节点的所有路径都包含相同数目的BLACK节点

      - 红黑树 和 4阶B树具有等价性

        - BLACK 节点和它的 RED 子节点融合在一起，形成一个B树节点
        - 红黑树的 BLACK节点个数与4阶B树的节点个数相等

      - 添加元素之后的操作

        - 因为等价于4阶B树，所以添加的元素在B树的叶子节点中，并且要满足节点元素个数x满足  1 ≤ x ≤ 3

        - 将添加的节点默认为 RED，则不影响性质1、2、3、5，只需针对4调整

        - 12种添加情况

          - 新增节点的 parent 为 BLACK（4种，分别是度为0的左右子位置和度为1的左右子位置），不需要调整
          - parent 为 RED 需要调整 (8种)
            - uncle 不是 RED（4种）
              - 是parent的右子节点，且 parent 是 grand 的 右子节点（RR），则 parent 染成 BLACK，grand 染成 RED，进行左旋转
              - 同上相反，LL 进行右旋转
              - 是 parent 的右子节点，parent 是 grand 的左子节点 （LR），则自己染成BLACK，grand染成RED，parent 左旋转，grand右旋转
              - 同上相反，RL parent 右旋转，grand左旋转
            - uncle 是 RED（4种）（上溢）
              - parent、uncle 染成 BLACK，grand 当成新增节点向上合并
              - 向上合并可能会继续发生上溢，直到根节点，将根节点染成 BLACK

          ```java
          @Override
          	protected void afterAdd(Node<E> node) {
          		Node<E> parent = node.parent;
          		
          		// 添加的是根节点 或者 上溢到达了根节点
          		if (parent == null) {
          			black(node);
          			return;
          		}
          		
          		// 如果父节点是黑色，直接返回
          		if (isBlack(parent)) return;
          		
          		// 叔父节点
          		Node<E> uncle = parent.sibling();
          		// 祖父节点
          		Node<E> grand = red(parent.parent);
          		if (isRed(uncle)) { // 叔父节点是红色【B树节点上溢】
          			black(parent);
          			black(uncle);
          			// 把祖父节点当做是新添加的节点
          			afterAdd(grand);
          			return;
          		}
          		
          		// 叔父节点不是红色
          		if (parent.isLeftChild()) { // L
          			if (node.isLeftChild()) { // LL
          				black(parent);
          			} else { // LR
          				black(node);
          				rotateLeft(parent);
          			}
          			rotateRight(grand);
          		} else { // R
          			if (node.isLeftChild()) { // RL
          				black(node);
          				rotateRight(parent);
          			} else { // RR
          				black(parent);
          			}
          			rotateLeft(grand);
          		}
          	}
          ```

          

      - 删除元素之后的操作

        - 等价于B树，则真正删除的元素在B树的叶子节点中
        - RED 节点
          - 直接删除，不用调整
        - BLACK 节点
          - 拥有2个 RED 子节点
            - 实际删除的是其子节点，可不用考虑
          - 拥有1个 RED 子节点
            - 替代的子节点是RED，则将替代的子节点染成 BLACK 即可
          - 叶子节点
            - 会导致B树节点下溢，则需要有元素补充
            - sibling 至少有1个RED子节点
              - 进行旋转操作，旋转后的中心节点继承 parent 的颜色，中心点的左右子节点染为 BLACK
            - sibling 没有1个RED子节点
              - 将 sibling 染成 RED、parent 染成 BLACK ，此时 parent 变成原所在B树节点的子节点
              - parent 原来是 BLACK，则说明原B树节点只有1个元素，此时产生下溢，则将 parent 当做被删除的节点继续往上处理
            - sibling 是 RED
              - sibling 染成BLACK，parent 染成 RED，并进行旋转，将 sibling 的子节点转成要删除节点的新 sibling，再进行 sibling 是 BLACK 时的处理

      - 时间复杂度
        - 搜索 Olog(n)
        - 添加 Olog(n)+O(1)旋转
        - 删除 Olog(n)+O(1)旋转





- leetcode

  - 链表

    - 206反转链表
      - 递归方法
      - 非递归 
    - 141环形链表
      - 快慢指针
    - 203移除链表元素
    - 83删除排序链表中的重复元素
    - 876链表中间节点

  - 栈

    - 20有效括号

    - 856刮号的分数

    - 150逆波兰表达式

    - 224基本计算器

    - 232用栈实现队列

      



- 备注

  - 扩容使用位运算效率高 （a*1.5 = a + a >> 1）

  - 树学习相关网站

    - http://520it.com/binarytrees/

    - http://btv.melezinek.cz/binary-search-tree.html

    - https://www.cs.usfca.edu/~galles/visualization/Algorithms.html

    - https://yangez.github.io/btree-js
    - https://www.codelike.in







- TODO

  - Blogs
    - Swift 数组实现源码

  - 树形结构打印器









- 资料
  - https://github.com/azl397985856/leetcode
  - https://github.com/diwu/LeetCode-Solutions-in-Swift
  - https://github.com/soapyigu/LeetCode-Swift