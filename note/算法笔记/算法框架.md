# 算法框架



## 动态规划

### 背包问题

> 给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的中粮为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少？

```
for 状态1 in 状态1的所有取值：
	for 状态2 in 状态2的所有取值:
		for ...
			dp[状态1][状态2][...] = 择优(选择1，选择2...)
```

1. 明确 **状态 **和 **选择**

   - 状态：背包的容量和可选择的物品

   - 选择：装进背包和不装进背包
2. 明确 dp 数组的定义和 base case

   - `dp[i][w]` 的定义：对于前 i 个物品，当前背包的容量为 w，可以装的最大价值为 `dp[i][w]`
   - base case：`dp[0][...] = dp[..][0] = ?`
3. 根据选择，思考 **状态转移** 的逻辑

   - 如果没有把第 i 个物品装进背包
   - 把第 i 个物品装进背包
4. （优化）判断是否可以进行状态压缩，将二维 dp 数组压成一维

### 复杂度

动态规划算法的时间复杂度就是**子问题的个数 * 函数本身的复杂度(忽略递归部分)**

### 相关题目

- 零钱兑换2 LC518
- 分割等和子集 LC416
- 编辑距离
- 高楼扔鸡蛋
- 最长公共子序列

## 回溯算法

## 二分查找



## 滑动窗口算法

```c++
void slidingWindow(std::string s, std::string t) {
    std::unordered_map<char, int> need, window;
    for (char c : t) need[c]++;
    
    int left = 0, right = 0;
    int valid = 0; 
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 右移窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        printf("window: [%d, %d)\n", left, right);
        /********************/
        
        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 左移窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}

模板下的四个问题：
  1. 当移动 right 拓大窗口，即加入字符时，应该更新哪些数据？
  2. 什么条件下，窗口应该暂停扩大，开始移动 left 缩小窗口？
  3. 当移动 left 缩小窗口，即移除字符时，应该更新哪些数据？
  4. 我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？
```

思路：

1. 使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。
2. 先不断地增加 right 指针扩大窗口 [left, right]，直到窗口符合要求
3. 停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求。同时，每次增加 left，我们都要更新一轮结果。
4. 重复第 2 和第 3 步，直到 right 到达尽头。

第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。 左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。

注意:

- 滑动窗口适用的题目一般具有单调性
- 滑动窗口、双指针、单调队列和单调栈经常配合使用



### 相关题目

- 最小覆盖子串 LC76
- 字符串排列 LC567
- 找所有字母异位词 LC438
- 最长无重复子串 LC3



## 双指针

### 快慢指针

主要解决链表中的问题，比如是否包含环、环起点、寻找中点、倒数第k个元素等

### 左右指针

主要解决数组或字符串的问题，比如二分查找、两数之和、反转数组、滑动指针算法



## BFS（广度优先）算法框架

```c++
// 计算从起点 start 到终点 target 的最近距离
int BFS(Node start, Node target) {
    Queue<Node> q; // 核心数据结构
    Set<Node> visited; // 避免走回头路

    q.offer(start); // 将起点加入队列
    visited.add(start);
    int step = 0; // 记录扩散的步数

    while (q not empty) {
        int sz = q.size();
        /* 将当前队列中的所有节点向四周扩散 */
        for (int i = 0; i < sz; i++) {
            Node cur = q.poll();
            /* 划重点：这里判断是否到达终点 */
            if (cur is target)
                return step;
            /* 将 cur 的相邻节点(adj())加入队列 */
            for (Node x : cur.adj())
                if (x not in visited) {
                    q.offer(x);
                    visited.add(x);
                }
        }
        /* 划重点：更新步数在这里 */
        step++;
    }
}
```

### 双向BFS

从起点和终点同时开始扩散，当两边有交集的时候停止。

不再使⽤队列，⽽是使⽤ HashSet ⽅便快速判断两个集合是否有交集。

### 相关题目

- 二叉树的最小深度 LC111
- 打开转盘锁 LC752