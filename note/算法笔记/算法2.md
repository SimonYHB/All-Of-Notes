- 11.集合
  - 用红黑树实现比链表性能高很多，但前提是元素具有可比较性
  - 红黑树增删查O(log(n))  链表增删查O(n)
  - 没有可比较性时，使用哈希表



- 12.映射 
  - 可以使用链表、二叉搜索树等数据结构实现



- 13.哈希表
  - 哈希函数计算序号+数组存储元素
  - 哈希冲突解决方法
    - 开放寻址法
    - 再哈希法
    - 链地址法（通过链表将同一index元素放在一起 ）
  - 哈希函数的实现
    1. 先生成 key 的哈希值（整数），越均匀越好
       - 不同种类key哈希值生成的方式不同
         - 整数直接存
         - 浮点数将存储的二进制格式转为整数
         - 字符串拆成若干个字符计算 j * n3 + a ∗ n2 + c ∗ n1 + k ∗ n0，jdk中n为31
         - 自定义对象使用内存地址或重新设计hash方法，通过内部元素计算
    2. 再让key的哈希值和数组大小进行计算，得到索引值
       - 通常使用&和%，&效率更高，但数组长度必须为2的幂
       - hash_code(key) & (table.length - 1)
       - 当数组长度为2的幂时，table.length-1 值都是1，&key后得到的结果都是<=table.length-1 
  - 两个对象equals成立则必须保证其hashCode函数也相等，反过来不一定

